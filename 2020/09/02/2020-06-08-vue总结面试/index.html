<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Nanno">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Nanno">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="vue总结如何实时修改data中数组中的值（数据改变试图改变）1his.$set(this.data,”key”,value’) delete和Vue.delete删除数组的区别delete只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。Vue.delete直接删除了数组 改变了数组的键值。 watch和computed区别 及二者使用场景 区别watch:  监">
<meta property="og:type" content="article">
<meta property="og:title" content="vue总结面试">
<meta property="og:url" content="https://nanno12.github.io/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Nanno">
<meta property="og:description" content="vue总结如何实时修改data中数组中的值（数据改变试图改变）1his.$set(this.data,”key”,value’) delete和Vue.delete删除数组的区别delete只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值还是不变。Vue.delete直接删除了数组 改变了数组的键值。 watch和computed区别 及二者使用场景 区别watch:  监">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://nanno12.github.io/2020/09/02/image/data-bind.png">
<meta property="og:image" content="https://nanno12.github.io/2020/09/02/image/vue-lifecycle.png">
<meta property="article:published_time" content="2020-09-02T03:33:00.000Z">
<meta property="article:modified_time" content="2020-09-14T05:31:50.314Z">
<meta property="article:author" content="Nanno">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nanno12.github.io/2020/09/02/image/data-bind.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>vue总结面试 · NANNO</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.1.1"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >NANNO</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">vue总结面试</a>
            </div>
    </div>
    
    <a class="home-link" href=/>NANNO</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            vue总结面试
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "面试">面试</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">9.1k</span>Reading time: <span class="post-count reading-time">33 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/09/02</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="vue总结"><a href="#vue总结" class="headerlink" title="vue总结"></a>vue总结</h2><h3 id="如何实时修改data中数组中的值（数据改变试图改变）"><a href="#如何实时修改data中数组中的值（数据改变试图改变）" class="headerlink" title="如何实时修改data中数组中的值（数据改变试图改变）"></a>如何实时修改data中数组中的值（数据改变试图改变）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">his.$set(<span class="built_in">this</span>.data,”key”,value’)</span><br></pre></td></tr></table></figure>
<h4 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h4><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。<br>Vue.delete直接删除了数组 改变了数组的键值。</p>
<h4 id="watch和computed区别-及二者使用场景"><a href="#watch和computed区别-及二者使用场景" class="headerlink" title="watch和computed区别 及二者使用场景"></a>watch和computed区别 及二者使用场景</h4><ul>
<li>区别<br>watch:  监听属性的变化；无缓存性，页面重新渲染时值不变化也会执行；<br>computed：是计算值；具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li>
<li>场景<br>watch：一个数据影响多个数据<br>computed：一个数据受多个数据影响</li>
</ul>
<h3 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h3><p>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</p>
<h3 id="请详细说下你对vue生命周期的理解"><a href="#请详细说下你对vue生命周期的理解" class="headerlink" title="请详细说下你对vue生命周期的理解"></a>请详细说下你对vue生命周期的理解</h3><blockquote>
<p>总共分为8个阶段。创建前后，载入前后，更新前后，销毁前后</p>
</blockquote>
<ul>
<li>创建前/后：<br>在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。<br>在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</li>
<li>载入前/后：<br>在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。<br>在mounted阶段，vue实例挂载完成，data.message成功渲染。</li>
<li>更新前/后：<br>当data变化时，会触发beforeUpdate和updated方法</li>
<li>销毁前/后：<br>在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在<h3 id="Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3></li>
<li>加载渲染过程：<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
<li>子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
<li>父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</li>
<li>销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
<h3 id="谈谈组件化和模块化的区别"><a href="#谈谈组件化和模块化的区别" class="headerlink" title="谈谈组件化和模块化的区别."></a>谈谈组件化和模块化的区别.</h3><ul>
<li>组件化：<br>组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合。<br>一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。<br>这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。</li>
<li>模块化：<br>模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，<br>以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。<br>将一个大的系统模块化之后，每个模块都可以被高度复用。</li>
<li>区别：<br>模块化的目的是为了重用，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。组件化的目的是为了解耦，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</li>
</ul>
<h3 id="vue单页面-首屏加载怎么优化"><a href="#vue单页面-首屏加载怎么优化" class="headerlink" title="vue单页面 首屏加载怎么优化"></a>vue单页面 首屏加载怎么优化</h3><ul>
<li>按需加载 基于DllPlugin 和 DllReferencePlugin 的 webpack 构建优化</li>
<li>加一个首屏 loading 图，提升用户体验；</li>
<li>将公用的JS库通过script标签外部引入</li>
<li>异步组件</li>
<li>优化组件加载时机</li>
</ul>
<h3 id="什么是MVVM。分别描述一下你对MVVM优缺点的理解"><a href="#什么是MVVM。分别描述一下你对MVVM优缺点的理解" class="headerlink" title="什么是MVVM。分别描述一下你对MVVM优缺点的理解"></a>什么是MVVM。分别描述一下你对MVVM优缺点的理解</h3><p>MVVM分为Model、View、ViewModel三者, 它是一种基于前端开发的架构模式。</p>
<p>其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。</p>
<ul>
<li>Model 代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>View 代表UI视图，负责数据的展示；</li>
<li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。<br>这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作 dom。</p>
<p>MVVM不仅简化了业务与界面的依赖关系，还优化了数据频繁更新的解决方案，甚至可以说提供了一种有效的解决模式。</p>
<p>MVVM用来做服务端是极其不适用的，因为：网络资源成本过高 开发成本过高</p>
<h3 id="vue-js的view-model是如何工作的"><a href="#vue-js的view-model是如何工作的" class="headerlink" title="vue.js的view-model是如何工作的"></a>vue.js的view-model是如何工作的</h3><p>Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。<br>它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，<br>保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。</p>
<h3 id="为什么vue组件中data必须是一个函数？"><a href="#为什么vue组件中data必须是一个函数？" class="headerlink" title="为什么vue组件中data必须是一个函数？"></a>为什么vue组件中data必须是一个函数？</h3><p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题</p>
<h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<ul>
<li>优点：<br>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；SPA 相对对服务器压力小；<br>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
<li>缺点<br>初次加载耗时多<br>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；<h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h3>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。<br>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</li>
</ul>
<h3 id="v-on可以监听多个方法吗？"><a href="#v-on可以监听多个方法吗？" class="headerlink" title="v-on可以监听多个方法吗？"></a>v-on可以监听多个方法吗？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-on=<span class="string">&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。<br>两者的区别：<br>assets:中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。<br>static:中的文件则不会被打包。</p>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p>
<h3 id="ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#ajax请求代码应该写在组件的methods中还是vuex的actions中" class="headerlink" title="ajax请求代码应该写在组件的methods中还是vuex的actions中"></a>ajax请求代码应该写在组件的methods中还是vuex的actions中</h3><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p>
<p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p>
<h2 id="vue面试题"><a href="#vue面试题" class="headerlink" title="vue面试题"></a>vue面试题</h2><p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016344599">Vue面试中，经常会被问到的面试题/Vue知识点整理</a></p>
<h3 id="1-vue-动态路由加载"><a href="#1-vue-动态路由加载" class="headerlink" title="1.vue 动态路由加载"></a>1.vue 动态路由加载</h3><p>在vue-router对象中首先初始化公共路由，比如（404，login）等，然后在用户登陆成功，根据用户的角色信息，获取对应权限菜单信息menuList，并将后台返回的menuList转换成我们需要的router数据结构，然后通过vue-router2.2新添的router.addRouter(routes)方法，同时我们可以将转后的路由信息保存于vuex，这样我们可以在我们的SideBar组件中获取我们的全部路由信息，并且渲染我们的左侧菜单栏，让动态路由实现。</p>
<ul>
<li>登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。</li>
<li>权限验证：通过token获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过router.addRoutes 动态挂载这些路由。</li>
</ul>
<p>参考： <a target="_blank" rel="noopener" href="https://www.jb51.net/article/145531.htm">vue后台管理之动态加载路由的方法</a></p>
<h3 id="2-webpack中alias配置"><a href="#2-webpack中alias配置" class="headerlink" title="2. webpack中alias配置"></a>2. webpack中alias配置</h3><p>作用:设置别名是为了让后续引用的地方减少路径的复杂度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.vue 里，正常引用 A 组件：</span></span><br><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">&#x27;../../components/a.vue&#x27;</span></span><br><span class="line"><span class="comment">//如果设置了 alias 后。</span></span><br><span class="line">alias: &#123;</span><br><span class="line">  <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;@&#x27;</span>: resolve(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">&#x27;@/components/a.vue&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-vue如何实现双向绑定"><a href="#3-vue如何实现双向绑定" class="headerlink" title="3.vue如何实现双向绑定"></a>3.vue如何实现双向绑定</h3><ul>
<li>vue数据双向绑定是通过 <strong>数据劫持</strong> 结合 <strong>发布者-订阅者模式</strong> 的方式来实现的.</li>
<li>vue是通过Object.defineProperty()来实现数据劫持的。它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举.有get和set两个方法。</li>
<li>实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据。视图更新数据其实可以通过事件监听即可，关键在于数据变化更新视图，通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</li>
<li>实现数据的双向绑定：</li>
</ul>
<ol>
<li><strong>实现一个监听器 Observer：</strong> 对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li>
<li><strong>实现一个解析器 Compile：</strong> 解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li><strong>实现一个订阅者 Watcher：</strong> Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li><strong>实现一个订阅器 Dep：</strong> 订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。<br><img src="../image/data-bind.png" alt="data-bind"></li>
</ol>
<h3 id="4-vue的生命周期"><a href="#4-vue的生命周期" class="headerlink" title="4. vue的生命周期"></a>4. vue的生命周期</h3><ul>
<li><strong>beforecreated</strong>  el、data、message未被初始化，此时可用于loading</li>
<li><strong>created</strong> 完成了data、message的初始化</li>
<li><strong>beforeMount</strong> 完成了el和data的初始化 ,但是el还是 ，这里就是应用的 Virtual DOM（虚拟Dom）技术，先把坑占住了。</li>
<li><strong>mounted</strong> 完成挂载，渲染值。</li>
<li><strong>beforeUpdate</strong> 可以监听到data的变化但是view层没有被重新渲染，view层的数据没有变化</li>
<li><strong>updated</strong> 等到updated的时候 view层才被重新渲染，数据更新。</li>
<li><strong>beforeDestroy</strong> 钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li><strong>destroyed</strong> 钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
<p><img src="../image/vue-lifecycle.png" alt="vue-lifecycle"></p>
<h3 id="5-vue的父子组件如何通信的"><a href="#5-vue的父子组件如何通信的" class="headerlink" title="5.vue的父子组件如何通信的"></a>5.vue的父子组件如何通信的</h3><ul>
<li>父组件是通过props属性给子组件通信</li>
<li>子组件通过触发事件来改变父组件的数据（this.$emit(method,data))。父组件通过监听子组件触发的事件，来调用方法，接收数据。</li>
<li>兄弟组件的通信，采用观察者模式。新建一个第三方实例。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组件他哥</span></span><br><span class="line">&lt;div @click=<span class="string">&quot;ge&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ge() &#123;</span><br><span class="line">        vm.$emit(<span class="string">&#x27;blur&#x27;</span>,<span class="string">&#x27;sichaoyun&#x27;</span>); <span class="comment">//触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组件小弟</span></span><br><span class="line">vm.$on(<span class="string">&#x27;blur&#x27;</span>, <span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test= arg; <span class="comment">// 接收</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-Vue的路由实现：hash模式-和-history模式"><a href="#6-Vue的路由实现：hash模式-和-history模式" class="headerlink" title="6.Vue的路由实现：hash模式 和 history模式"></a>6.Vue的路由实现：hash模式 和 history模式</h3><ul>
<li><strong>hash模式：</strong> 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；</li>
<li>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a target="_blank" rel="noopener" href="http://www.xxx.com,因此对于后端来说,即使没有做到对路由的全覆盖,也不会返回/">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</li>
<li><strong>history模式：</strong> history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。</li>
<li>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a target="_blank" rel="noopener" href="http://www.xxx.com/items/id%E3%80%82%E5%90%8E%E7%AB%AF%E5%A6%82%E6%9E%9C%E7%BC%BA%E5%B0%91%E5%AF%B9">http://www.xxx.com/items/id。后端如果缺少对</a> /items/id 的路由处理，将返回 404 错误。</li>
</ul>
<h3 id="7-vue-cli如何新增自定义指令？"><a href="#7-vue-cli如何新增自定义指令？" class="headerlink" title="7.vue-cli如何新增自定义指令？"></a>7.vue-cli如何新增自定义指令？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建局部指令</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 创建指令(可以多个)</span></span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="comment">// 指令名称</span></span><br><span class="line">        dir1: &#123;</span><br><span class="line">            inserted(el) &#123;</span><br><span class="line">                el.style.width = <span class="string">&#x27;200px&#x27;</span>;</span><br><span class="line">            &#125;&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">//创建全局指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;dir2&#x27;</span>, &#123;</span><br><span class="line">    inserted(el) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//指令的使用</span></span><br><span class="line">&lt;div v-dir1&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-vue如何自定义一个过滤器？"><a href="#8-vue如何自定义一个过滤器？" class="headerlink" title="8.vue如何自定义一个过滤器？"></a>8.vue如何自定义一个过滤器？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">     &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;msg&quot;</span> /&gt;</span><br><span class="line">     &#123;&#123;msg| capitalize &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">      capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        value = value.toString()</span><br><span class="line">        <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="9-对keep-alive-的了解？"><a href="#9-对keep-alive-的了解？" class="headerlink" title="9.对keep-alive 的了解？"></a>9.对keep-alive 的了解？</h3><ul>
<li>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</li>
<li>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</li>
</ul>
<h3 id="10-vue中-key-值的作用？"><a href="#10-vue中-key-值的作用？" class="headerlink" title="10. vue中 key 值的作用？"></a>10. vue中 key 值的作用？</h3><ul>
<li>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。</li>
</ul>
<h3 id="11-什么是vue的计算属性？"><a href="#11-什么是vue的计算属性？" class="headerlink" title="11.什么是vue的计算属性？"></a>11.什么是vue的计算属性？</h3><p>在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。</p>
<h3 id="12-vuex原理"><a href="#12-vuex原理" class="headerlink" title="12. vuex原理"></a>12. vuex原理</h3><ul>
<li>vuex的store有State、 Getter、Mutation 、Action、 Module五种属性；</li>
<li><strong>state</strong> 为单一状态树，在state中需要定义我们所需要管理的数组、对象、字符串等等</li>
<li><strong>getters</strong> 类似vue的计算属性，主要用来过滤一些数据。</li>
<li><strong>mutation</strong> 更改store中state状态的唯一方法就是提交mutation，store.commit。</li>
<li><strong>action</strong> actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li>
<li><strong>module</strong> module其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，每个模块中拥有自己的state、mutation、action和getter。</li>
</ul>
<h3 id="13-vue数据双向绑定"><a href="#13-vue数据双向绑定" class="headerlink" title="13. vue数据双向绑定"></a>13. vue数据双向绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;txt&quot;</span>&gt;</span><br><span class="line">    &lt;p id=<span class="string">&quot;show&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;txt&#x27;</span>, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;txt&#x27;</span>).value = newValue</span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&#x27;show&#x27;</span>).innerHTML = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        obj.txt = e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="14-父子组件如何通信，兄弟组件如何通信"><a href="#14-父子组件如何通信，兄弟组件如何通信" class="headerlink" title="14. 父子组件如何通信，兄弟组件如何通信"></a>14. 父子组件如何通信，兄弟组件如何通信</h3><ol>
<li>props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit和v-on来向上传递信息。</li>
<li>EventBus: 通过EventBus进行信息的发布与订阅。这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</li>
<li>vuex: 是全局数据管理库，可以通过vuex管理全局的数据流。</li>
<li>$attrs/$listeners: Vue2.4中加入的$attrs/$listeners可以进行跨级的组件通信</li>
<li>provide/inject：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础</li>
</ol>
<h3 id="15-Proxy与Object-defineProperty的优劣对比"><a href="#15-Proxy与Object-defineProperty的优劣对比" class="headerlink" title="15. Proxy与Object.defineProperty的优劣对比?"></a>15. Proxy与Object.defineProperty的优劣对比?</h3><ul>
<li><strong>Object.defineProperty的缺点</strong></li>
</ul>
<ol>
<li>无法监听数组变化。Vue的文档提到了Vue是可以检测到数组变化的，但是只有以下八种方法,vm.items[indexOfItem] = newValue这种是无法检测的。</li>
<li>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</li>
</ol>
<ul>
<li><strong>Proxy的优点：</strong></li>
</ul>
<ol>
<li>Proxy可以直接监听对象而非属性</li>
<li>Proxy可以直接监听数组的变化</li>
<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>
<li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li>
<li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。</li>
</ol>
<ul>
<li><strong>Object.defineProperty的优点 &amp;&amp; Proxy的缺点</strong></li>
</ul>
<ol>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li>
</ol>
<h3 id="16-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#16-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="16. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>16. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><strong>加载渲染过程</strong>：</li>
<li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
<li><strong>子组件更新过程</strong></li>
<li>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
<li><strong>父组件更新过程</strong></li>
<li>父 beforeUpdate -&gt; 父 updated</li>
<li><strong>销毁过程</strong></li>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
<h3 id="17-在哪个生命周期内调用异步请求？"><a href="#17-在哪个生命周期内调用异步请求？" class="headerlink" title="17. 在哪个生命周期内调用异步请求？"></a>17. 在哪个生命周期内调用异步请求？</h3><ul>
<li>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</li>
</ul>
<ol>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ol>
<h3 id="18-父组件可以监听到子组件的生命周期吗？"><a href="#18-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="18. 父组件可以监听到子组件的生命周期吗？"></a>18. 父组件可以监听到子组件的生命周期吗？</h3><ul>
<li>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">&quot;doSomething&quot;</span> &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;父组件监听到 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Child.vue</span></span><br><span class="line">mounted()&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以上输出顺序为：</span></span><br><span class="line"><span class="comment">// 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line"><span class="comment">// 父组件监听到 mounted 钩子函数 ...     </span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="19-谈谈你对-keep-alive-的了解？"><a href="#19-谈谈你对-keep-alive-的了解？" class="headerlink" title="19. 谈谈你对 keep-alive 的了解？"></a>19. 谈谈你对 keep-alive 的了解？</h3><ul>
<li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</li>
</ul>
<ol>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ol>
<h3 id="20-组件中-data-为什么是一个函数？"><a href="#20-组件中-data-为什么是一个函数？" class="headerlink" title="20. 组件中 data 为什么是一个函数？"></a>20. 组件中 data 为什么是一个函数？</h3><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</p>
<h3 id="21-使用过-Vue-SSR-吗？说说-SSR？"><a href="#21-使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="21. 使用过 Vue SSR 吗？说说 SSR？"></a>21. 使用过 Vue SSR 吗？说说 SSR？</h3><ul>
<li>SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做<strong>服务端渲染</strong>。</li>
<li>服务端渲染 SSR 的优缺点如下：</li>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ol>
<ul>
<li><strong>缺点：</strong></li>
</ul>
<ol>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ol>
<h3 id="22-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#22-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="22. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>22. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><ul>
<li><strong>hash 模式的实现原理</strong></li>
</ul>
<ol>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ol>
<ul>
<li><strong>history 模式的实现原理</strong></li>
</ul>
<ol>
<li>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ol>
<h3 id="23-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#23-Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="23. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>23. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式  </span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值  </span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果目标是数组，直接使用数组的 splice 方法触发响应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用  defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ol>
<h3 id="24-说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#24-说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="24. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>24. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><ul>
<li>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</li>
<li><strong>优点</strong>：</li>
</ul>
<ol>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ol>
<ul>
<li><strong>缺点</strong>：</li>
</ul>
<ol>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ol>
<h3 id="25-v-show-与-v-if-有什么区别？"><a href="#25-v-show-与-v-if-有什么区别？" class="headerlink" title="25. v-show 与 v-if 有什么区别？"></a>25. v-show 与 v-if 有什么区别？</h3><ol>
<li>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li>
<li>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</li>
<li>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</li>
</ol>
<h3 id="26-computed-和-watch-的区别和运用的场景？"><a href="#26-computed-和-watch-的区别和运用的场景？" class="headerlink" title="26. computed 和 watch 的区别和运用的场景？"></a>26. computed 和 watch 的区别和运用的场景？</h3><ul>
<li><strong>computed：</strong>  是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li><strong>watch：</strong>  更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="27-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#27-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="27. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>27. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><ul>
<li>加载渲染过程： 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
<li>子组件更新过程： 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
<li>父组件更新过程： 父 beforeUpdate -&gt; 父 updated</li>
<li>销毁过程： 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
<h3 id="28-你有对-Vue-项目进行哪些优化？"><a href="#28-你有对-Vue-项目进行哪些优化？" class="headerlink" title="28. 你有对 Vue 项目进行哪些优化？"></a>28. 你有对 Vue 项目进行哪些优化？</h3><ul>
<li><strong>代码层面的优化</strong></li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> v-if 和 v-show 区分使用场景</li>
<li><input disabled="" type="checkbox"> computed 和 watch  区分使用场景</li>
<li><input disabled="" type="checkbox"> v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li><input disabled="" type="checkbox"> 长列表性能优化</li>
<li><input disabled="" type="checkbox"> 事件的销毁</li>
<li><input disabled="" type="checkbox"> 图片资源懒加载</li>
<li><input disabled="" type="checkbox"> 路由懒加载</li>
<li><input disabled="" type="checkbox"> 第三方插件的按需引入</li>
<li><input disabled="" type="checkbox"> 优化无限列表性能</li>
<li><input disabled="" type="checkbox"> 服务端渲染 SSR or 预渲染</li>
</ul>
<ul>
<li><strong>Webpack 层面的优化</strong></li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> Webpack 对图片进行压缩</li>
<li><input disabled="" type="checkbox"> 减少 ES6 转为 ES5 的冗余代码</li>
<li><input disabled="" type="checkbox"> 提取公共代码</li>
<li><input disabled="" type="checkbox"> 模板预编译</li>
<li><input disabled="" type="checkbox"> 提取组件的 CSS</li>
<li><input disabled="" type="checkbox"> 优化 SourceMap</li>
<li><input disabled="" type="checkbox"> 构建结果输出分析</li>
<li><input disabled="" type="checkbox"> Vue 项目的编译优化</li>
</ul>
<ul>
<li><strong>基础的 Web 技术的优化</strong></li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> 开启 gzip 压缩</li>
<li><input disabled="" type="checkbox"> 浏览器缓存</li>
<li><input disabled="" type="checkbox"> CDN 的使用</li>
<li><input disabled="" type="checkbox"> 使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h3 id="29-对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#29-对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="29. 对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>29. 对于即将到来的 vue3.0 特性你有什么了解的吗？</h3><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<ul>
<li><strong>监测机制的改变</strong></li>
</ul>
<p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ol>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。</li>
</ol>
<p>新的 observer 还提供了以下特性：</p>
<ol>
<li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ol>
<ul>
<li><strong>模板</strong></li>
</ul>
<p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p>
<p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p>
<ul>
<li><strong>对象式的组件声明方式</strong></li>
</ul>
<p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p>
<p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<ul>
<li><strong>其它方面的更改</strong></li>
</ul>
<p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p>
<ol>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ol>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://nanno12.github.io">Nanno</a>
            <p>原文链接：<a href="https://nanno12.github.io/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/">https://nanno12.github.io/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/</a>
            <p>发表日期：<a href="https://nanno12.github.io/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/">September 2nd 2020, 11:33:00 am</a>
            <p>更新日期：<a href="https://nanno12.github.io/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/">September 14th 2020, 1:31:50 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/09/02/2020-06-08-vue-router/" title= "Vue-router">
                    <div class="nextTitle">Vue-router</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/09/02/2020-06-08-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%BC%E5%90%88(%E4%BA%8C)/" title= "web前端面试题(二)">
                    <div class="prevTitle">web前端面试题(二)</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:nannow127@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/nanno12" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">vue总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E6%97%B6%E4%BF%AE%E6%94%B9data%E4%B8%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%80%BC%EF%BC%88%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E8%AF%95%E5%9B%BE%E6%94%B9%E5%8F%98%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">如何实时修改data中数组中的值（数据改变试图改变）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#delete%E5%92%8CVue-delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">delete和Vue.delete删除数组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch%E5%92%8Ccomputed%E5%8C%BA%E5%88%AB-%E5%8F%8A%E4%BA%8C%E8%80%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">watch和computed区别 及二者使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">vue如何监听对象或者数组某个属性的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%8B%E4%BD%A0%E5%AF%B9vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">请详细说下你对vue生命周期的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">Vue 的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">谈谈组件化和模块化的区别.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%8D%95%E9%A1%B5%E9%9D%A2-%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">vue单页面 首屏加载怎么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVVM%E3%80%82%E5%88%86%E5%88%AB%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9MVVM%E4%BC%98%E7%BC%BA%E7%82%B9%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">什么是MVVM。分别描述一下你对MVVM优缺点的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-js%E7%9A%84view-model%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.8.</span> <span class="toc-text">vue.js的view-model是如何工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E4%B8%ADdata%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">为什么vue组件中data必须是一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%8B%E5%B0%81%E8%A3%85-vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">请说下封装 vue 组件的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-on%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">v-on可以监听多个方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assets%E5%92%8Cstatic%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.</span> <span class="toc-text">assets和static的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slot%E6%8F%92%E6%A7%BD"><span class="toc-number">1.14.</span> <span class="toc-text">slot插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%A0%81%E5%BA%94%E8%AF%A5%E5%86%99%E5%9C%A8%E7%BB%84%E4%BB%B6%E7%9A%84methods%E4%B8%AD%E8%BF%98%E6%98%AFvuex%E7%9A%84actions%E4%B8%AD"><span class="toc-number">1.15.</span> <span class="toc-text">ajax请求代码应该写在组件的methods中还是vuex的actions中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">vue面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vue-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1.vue 动态路由加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-webpack%E4%B8%ADalias%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2. webpack中alias配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-vue%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">2.3.</span> <span class="toc-text">3.vue如何实现双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.4.</span> <span class="toc-text">4. vue的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-vue%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84"><span class="toc-number">2.5.</span> <span class="toc-text">5.vue的父子组件如何通信的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F-%E5%92%8C-history%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">6.Vue的路由实现：hash模式 和 history模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vue-cli%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7.vue-cli如何新增自定义指令？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-vue%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8.vue如何自定义一个过滤器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AF%B9keep-alive-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">9.对keep-alive 的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-vue%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">10. vue中 key 值的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AFvue%E7%9A%84%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">11.什么是vue的计算属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-vuex%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.</span> <span class="toc-text">12. vuex原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">2.13.</span> <span class="toc-text">13. vue数据双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.14.</span> <span class="toc-text">14. 父子组件如何通信，兄弟组件如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Proxy%E4%B8%8EObject-defineProperty%E7%9A%84%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-number">2.15.</span> <span class="toc-text">15. Proxy与Object.defineProperty的优劣对比?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">16. Vue 的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">17. 在哪个生命周期内调用异步请求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">18. 父组件可以监听到子组件的生命周期吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-keep-alive-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">19. 谈谈你对 keep-alive 的了解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">20. 组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BD%BF%E7%94%A8%E8%BF%87-Vue-SSR-%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4-SSR%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">21. 使用过 Vue SSR 吗？说说 SSR？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%83%BD%E8%AF%B4%E4%B8%8B-vue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-hash-%E5%92%8C-history-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">22. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-Vue-%E6%80%8E%E4%B9%88%E7%94%A8-vm-set-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98-%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">23. Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.24.</span> <span class="toc-text">24. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-v-show-%E4%B8%8E-v-if-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.25.</span> <span class="toc-text">25. v-show 与 v-if 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.26.</span> <span class="toc-text">26. computed 和 watch 的区别和运用的场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Vue-%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.27.</span> <span class="toc-text">27. Vue 的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%BD%A0%E6%9C%89%E5%AF%B9-Vue-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">28. 你有对 Vue 项目进行哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%AF%B9%E4%BA%8E%E5%8D%B3%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84-vue3-0-%E7%89%B9%E6%80%A7%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">2.29.</span> <span class="toc-text">29. 对于即将到来的 vue3.0 特性你有什么了解的吗？</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 35
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger">
                <span class="iconfont-archer search-icon">&#xe627;</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2020/09/14/vue%E6%80%BB%E7%BB%93/" >vue 总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2020/09/14/Esc/" >ES6 总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2020/09/14/webpack%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95/" >webpack 相关面试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2020/09/14/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E9%A2%98/" >前端常见代码面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2020/09/14/%E6%80%A7%E8%83%BD%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" >性能安全网络浏览器相关知识</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/http%20%E9%9D%A2%E8%AF%95/" >http 面试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/2020-09-10-AJAX/" >AJAX</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/2020-09-10-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/" >同步异步</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/2020-09-10-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" >深浅拷贝</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/dom%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0/" >dom 事件绑定函数以及 dom 操作</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2020/09/10/2020-09-10-%E7%8E%AF%E5%A2%83/" >环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-03-23-js%E9%9D%A2%E8%AF%95%E9%A2%98/" >js面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-06-08-Vuex/" >Vuex</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-06-08-vue-router/" >Vue-router</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-06-08-vue%E6%80%BB%E7%BB%93%E9%9D%A2%E8%AF%95/" >vue总结面试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-06-08-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%BC%E5%90%88(%E4%BA%8C)/" >web前端面试题(二)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2020/09/02/2020-08-24-html,css%E6%A0%B7%E5%BC%8F%E9%9D%A2%E8%AF%95/" >html,css面试</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2019-06-03-VSCode%E9%BB%98%E8%AE%A4%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E6%8F%92%E4%BB%B6/" >vscode代码片段</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-03-23-element-tag%E6%A0%87%E7%AD%BE%E5%8F%AF%E4%BF%AE%E6%94%B9/" >element标签取值</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-03-23-%E5%B8%B8%E8%A7%81%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/" >常见的HTTP状态码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-04-02-js%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E5%85%83%E7%B4%A0/" >js判断数组某元素是否存在</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-04-02-vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/" >vue自定义指令</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-04-02-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/" >键盘事件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-05-08-webpack%E6%89%93%E5%8C%85/" >webpack面试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-06-03-flex%E5%B8%83%E5%B1%80/" >flex布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-06-03-git%E5%91%BD%E4%BB%A4/" >Git</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-06-04-CSS%E4%B8%8D%E5%AE%9A%E9%AB%98%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/" >CSS垂直水平居中</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-06-05-ele+vue%20%E8%A1%A8%E6%A0%BC%E5%A4%9A%E9%80%89%E5%9B%9E%E6%98%BE/" >ele+vue 表格多选回显</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-06-05-elementUI%E6%A1%86%E6%9E%B6%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/" >elementUI框架问题集合</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span><a class="archive-post-title" href= "/2020/08/19/2020-01-22-js%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" >第五章 引用类型</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/09</span><a class="archive-post-title" href= "/2020/07/09/2020-07-09-js%E6%9C%89%E5%85%B3js%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E8%AF%95%E9%A2%98/" >有关js原型、原型链、作用域链试题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span><a class="archive-post-title" href= "/2020/06/10/2020-06-10-react%E8%AF%AD%E6%B3%95/" >React</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span><a class="archive-post-title" href= "/2020/06/04/2019-11-14-vue%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B9%B4%E6%9C%88%E6%97%A5/" >vue当前时间转换成年月日</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span><a class="archive-post-title" href= "/2020/06/04/2020-05-17-js%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C%E6%96%B9%E6%B3%95/" >js数组求和方法</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/08</span><a class="archive-post-title" href= "/2019/08/08/2020-09-01-%E9%9D%A2%E8%AF%95%E9%A2%98%E9%93%BE%E6%8E%A5/" >面试博客链接</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="使用"><span class="iconfont-archer">&#xe606;</span>使用</span>
    
        <span class="sidebar-tag-name" data-tags="vscode"><span class="iconfont-archer">&#xe606;</span>vscode</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="Element"><span class="iconfont-archer">&#xe606;</span>Element</span>
    
        <span class="sidebar-tag-name" data-tags="面试"><span class="iconfont-archer">&#xe606;</span>面试</span>
    
        <span class="sidebar-tag-name" data-tags="Http"><span class="iconfont-archer">&#xe606;</span>Http</span>
    
        <span class="sidebar-tag-name" data-tags="Vue"><span class="iconfont-archer">&#xe606;</span>Vue</span>
    
        <span class="sidebar-tag-name" data-tags="Css"><span class="iconfont-archer">&#xe606;</span>Css</span>
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="框架"><span class="iconfont-archer">&#xe606;</span>框架</span>
    
        <span class="sidebar-tag-name" data-tags="封装"><span class="iconfont-archer">&#xe606;</span>封装</span>
    
        <span class="sidebar-tag-name" data-tags="Ajax"><span class="iconfont-archer">&#xe606;</span>Ajax</span>
    
        <span class="sidebar-tag-name" data-tags="Es"><span class="iconfont-archer">&#xe606;</span>Es</span>
    
        <span class="sidebar-tag-name" data-tags="前端常见代码面试题"><span class="iconfont-archer">&#xe606;</span>前端常见代码面试题</span>
    
        <span class="sidebar-tag-name" data-tags="html"><span class="iconfont-archer">&#xe606;</span>html</span>
    
        <span class="sidebar-tag-name" data-tags="css"><span class="iconfont-archer">&#xe606;</span>css</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="其他"><span class="iconfont-archer">&#xe60a;</span>其他</span>
    
        <span class="sidebar-category-name" data-categories="js方法"><span class="iconfont-archer">&#xe60a;</span>js方法</span>
    
        <span class="sidebar-category-name" data-categories="js"><span class="iconfont-archer">&#xe60a;</span>js</span>
    
        <span class="sidebar-category-name" data-categories="css"><span class="iconfont-archer">&#xe60a;</span>css</span>
    
        <span class="sidebar-category-name" data-categories="vue"><span class="iconfont-archer">&#xe60a;</span>vue</span>
    
        <span class="sidebar-category-name" data-categories="配置"><span class="iconfont-archer">&#xe60a;</span>配置</span>
    
        <span class="sidebar-category-name" data-categories="Element问题"><span class="iconfont-archer">&#xe60a;</span>Element问题</span>
    
        <span class="sidebar-category-name" data-categories="react"><span class="iconfont-archer">&#xe60a;</span>react</span>
    
        <span class="sidebar-category-name" data-categories="面试慕课讲解"><span class="iconfont-archer">&#xe60a;</span>面试慕课讲解</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Nanno"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


